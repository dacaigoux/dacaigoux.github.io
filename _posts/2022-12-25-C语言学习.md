---
layout: post
title: C语言学习
author: DaCaiGouX
date: 2022-12-25 15:14+0800
tags: 
- C
toc: true
excerpt_separator: <!--more-->
---
*C语言的一些基础知识*
<!--more-->

- [4 基本元素](#4-基本元素)
  - [4.1 字符集](#41-字符集)
  - [4.2 token](#42-token)
  - [4.3 对象](#43-对象)
  - [4.4 "副作用"](#44-副作用)
  - [4.5 printf函数](#45-printf函数)
- [5 基本数据类型](#5-基本数据类型)
  - [5.1 整数类型](#51-整数类型)
  - [5.2 浮点类型](#52-浮点类型)
  - [5.3 数据精度与类型转换](#53-数据精度与类型转换)
  - [5.4 运算操作符](#54-运算操作符)
  - [5.5 sizeof操作符](#55-sizeof操作符)
  - [5.6 投射操作符](#56-投射操作符)
- [6 \*用户自定义类型](#6-用户自定义类型)
  - [6.1 枚举类型](#61-枚举类型)
  - [6.2 结构体类型](#62-结构体类型)
  - [6.3联合体类型](#63联合体类型)
  - [6.4 位域](#64-位域)
  - [6.5 字节对齐与字节填充](#65-字节对齐与字节填充)
  - [6.6 复数类型](#66-复数类型)
- [7 数组和指针](#7-数组和指针)
  - [7.1 一维数组](#71-一维数组)
  - [7.2 多维数组](#72-多维数组)
  - [7.3 变长数组](#73-变长数组)
  - [7.4 一级指针与对象地址](#74-一级指针与对象地址)
  - [7.5 多级指针](#75-多级指针)
  - [7.7 指针与数组](#77-指针与数组)
  - [7.8 指向数组的指针](#78-指向数组的指针)
  - [7.9 void类型、指向void类型的指针和空指针](#79-void类型指向void类型的指针和空指针)
  - [7.10 字符数组与字符串字面量](#710-字符数组与字符串字面量)
  - [7.11 完整与不完整类型](#711-完整与不完整类型)
  - [7.12 灵活的数组成员](#712-灵活的数组成员)
- [8 控制流语句](#8-控制流语句)
  - [8.1 逗号表达式](#81-逗号表达式)
  - [8.2 条件表达式](#82-条件表达式)
  - [8.3 if-else语句](#83-if-else语句)
  - [8.4 switch-case语句](#84-switch-case语句)
  - [8.5 while和do-while迭代语句](#85-while和do-while迭代语句)
  - [8.6 for迭代语句](#86-for迭代语句)
  - [8.7 goto语句](#87-goto语句)
- [9 函数](#9-函数)
  - [9.1 函数的声明与定义](#91-函数的声明与定义)
  - [9.2 \*函数的实现和调用](#92-函数的实现和调用)
  - [9.3 \*数组类型作为函数形参](#93-数组类型作为函数形参)
  - [9.4 带有不定参数类型及个数的函数声明与调用](#94-带有不定参数类型及个数的函数声明与调用)
  - [9.5 递归调用](#95-递归调用)
  - [9.6 \*内联函数](#96-内联函数)
  - [9.7 函数返回类型和无返回函数](#97-函数返回类型和无返回函数)
  - [9.8 指向函数的指针](#98-指向函数的指针)
  - [9.9主函数main](#99主函数main)
  - [9.10 函数与函数调用作为sizeof操作符](#910-函数与函数调用作为sizeof操作符)
- [10 预处理器](#10-预处理器)
  - [10.1 宏定义（控制行类）](#101-宏定义控制行类)
  - [10.2 C语言中预定义的宏(由编译工具定义好的宏)](#102-c语言中预定义的宏由编译工具定义好的宏)
  - [10.3 条件预编译](#103-条件预编译)
  - [10.4 源文件包含预处理指示符](#104-源文件包含预处理指示符)
  - [10.5 #error和#warning预处理指示符](#105-error和warning预处理指示符)
  - [10.6 #line预处理指示符](#106-line预处理指示符)
  - [10.7 #undef 预处理指示符](#107-undef-预处理指示符)
  - [10.8 #pragma和\_Pragma](#108-pragma和_pragma)

### 4 基本元素
      
      ```c
      #include <stdio.h>        //这时预处理器,将stdio.h中的所有内容放到我们所写地源码中
      // 这是单行注释
      /*
      这是多行注释
      */
      int main()//main()这是主函数入口,最先被执行
      {        //被{}包围着函数的具体实现代码
      printf("Hello World\n");
      return 0;
      }
      ```

#### 4.1 字符集

#### 4.2 token

```c
int a = 3 <<2;
//这里有7个token int、a、=、3、<<、2以及最后的分号；每个token之间需要用空格分隔开
```

1. 标识符
   
   c语言中,标识符可以表示对象、函数、结构体、联合体、枚举。
   
   ***有效标识符：** 符由基本字符集中的所有⼤⼩写英 ⽂字母、阿拉伯数字0到9以及下划线_构成，并且标识符不能以数字开头。
   
   例如： aBc、_ab、C11、_3_都是有效的标识符；5ab、a（2、886 都是无效标识符。

2. 关键字
   
   关键字：被编程语言编译器保留用作特定语义的token，他们不可以被我们但做其他标识符使用。

3. 常量与字符串面量
   
   常量：整数常量、浮点数长量、枚举常量、字符常量
   
   字符串面量： ⼀个字符串字⾯量由⼀对 双引号包裹的⼀系列的字符构成。如果字符串中含有诸如回车、双引号等 字符的话，需要对它们进⾏转义。

```c
"Hello World\n" //这就是一个字符串面量
```

4. 操作符(标点符号)
   
   1.标点符号:
   
   [ ] （ ） { } . -> ++ -- & * + - ~ ！ / % << >> < > <= >= == ！= ^ | && || ？ ： ； ... = *= /= %= += -= <<= >>= &= ^= |= ， # ## <： ：> <% %> %： %：%：
   
   1. 单目操作符、双目操作符、三目操作符
      
      1）单⽬操作符有！（表⽰逻辑⾮）、&（⽤作地址操作符时）、 *（作为间接操作符时）、+（表⽰正数符号时）、-（表⽰负数符号时）、 ~（表⽰按位取反）。
      2）双⽬操作符有++（表⽰⾃增操作）、--（表⽰⾃减操作）。
      3）三⽬操作符只有⼀组，即？与：的组合。
      
      其余的，除了#和##作为预处理操作符之外，上述 `1.标点符号`列出的操作数中都是 双⽬操作符。

***注意:**

若一个表达式中有多个操作符，先从优先级高的开始。优先级顺序：
1）基本表达式：标识符、常量、字符串字⾯量、圆括号表达式（⽐如 （3+2））、泛型表达式。
2）后缀操作符：数组下标（⽐如a[0]）、函数调⽤、结构体与联合体 成员访问操作符（.和->）、后缀⾃增及⾃减操作符（⽐如a++；a--）、复 合字⾯量（⽐如（int[]）{1，2，3}）。
3）单⽬操作符：前缀⾃增与⾃减操作符、地址操作符与间接操作符 （⽐如++a；--a）、单⽬算术操作符（+、-、！、~，其中这⾥的+和-表⽰ 正负号）、sizeof操作符与_Alignof操作符。
4）类型投射操作符。
5）乘法操作符（包括乘、除、求余数 `*`、/、%）。
6）加法操作符（+、-）。 7）移位操作符（左移、右移）。
8）关系操作符（⼤于、⼩于、⼤于等于、⼩于等于）。
9）相等性操作符（等于和不等于，==、！=）。
10）按位与操作符。
11）按位异或操作符。
12）按位或操作符。
13）逻辑与操作符。
14）逻辑或操作符。
15）条件操作符（即三⽬表达式）。
16）赋值操作符。
17）逗号操作符。

#### 4.3 对象

C11标准将“对象”定义为执⾏环境中的数据存储区域，对象中的内容⽤于表达它的值。

字面量: 在传统编 程语⾔中，字⾯量就是指在源代码中⽤于表⽰⼀个固定值的⽂字记号。 ⽐如，像3、-10、3.14、"hello"等都属于字⾯量。 3、-10表⽰整数字⾯量; 3.14表⽰浮点数字⾯量;"hello"表⽰⼀个字符串字⾯量。

#### 4.4 "副作用"

在C源代码中的某⼀条表达式在⽬标程序 中执⾏时，对当前程序的执⾏状态产⽣了或潜在产⽣改变，那么我们称该 表达式产⽣了副作⽤。

#### 4.5 printf函数

```c
int printf(const char * restrict format, ...);  //printf的原型
```

注意：

1.省略号表示不定个数的参数。

2.这些参数的数据类型需要与format所指的字符串格式匹配。

3.最终返回的是int类型整数

4. 常用的format字符串中格式符：
   1）%c：对应参数是⼀个int类型，但实际运⾏时会将该int类型对象转
   换为unsigned char类型。
   2）%d：对应参数是⼀个int类型。
   3）%f：对应参数是⼀个double类型。
   4）%ld：对应参数是⼀个long int类型。
   5）%s：对应参数是⼀个const char*类型，表⽰输出⼀个字符串。
   6）%u：对应参数是⼀个unsigned int类型。
   7）%zu：对应参数是⼀个size_t类型。
   8）%td：对应参数是⼀个ptrdiff_t类型。
   9）%x（或%X）：对应参数是⼀个int类型，不过会以⼗六进制形式输
   出，其中⼤于9的数字根据字母x⼤⼩写进⾏转换，如果是%x，则⼤于9的
   数⽤a～f表⽰；如果是%X，则⽤A～F表⽰。
   10）%%：输出⼀个%符号。
11) %hu对应⼀个unsigned short类型

### 5 基本数据类型

C语言中分为两大类：整数类型（包括字符类型和布尔类型）、浮点类型（单精度浮点数、双精度负浮点数、扩展双精度浮点数）。

#### 5.1 整数类型

1).都支持带符号和不带符号的表示方式。

| 类型             | 存储大小     | 值范围                                               |
|:-------------- |:-------- |:------------------------------------------------- |
| char           | 1 字节     | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节     | 0 到 255                                           |
| signed char    | 1 字节     | -128 到 127                                        |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节     | -32,768 到 32,767                                  |
| unsigned short | 2 字节     | 0 到 65,535                                        |
| long           | 4 字节     | -2,147,483,648 到 2,147,483,647                    |
| unsigned long  | 4 字节     | 0 到 4,294,967,295                                 |

2). 整数字⾯量可以分别使⽤⼋进制、⼗进制以及⼗六进制的⽅式进⾏表达。⼋进制的整数字⾯量表达⽅式为以0打头，⽐如：01、023、-0477这些都是属于⼋进制整数字⾯量。⽽⼗六进制整数字⾯量则是以0x或0X打头，⽐如：0x123、-0x0045、0xabcdef 这些都是有效的⼗六进制整数字⾯量。⽽其他没有任何前缀的整数字⾯量都表⽰为⼗进制整数。

1. int类型
   
   **格式符: %d**
   
   int数据的最⼩值与最⼤值分别定义为头⽂件中的INT_MIN 和INT_MAX。

```c
INT_MAX:2147483647
INT_MIN:-2147483648
INT_MAX:0x7fffffff
INT_MIN:0x80000000
```

如果想要表达⼀个unsigned int类型的整数字⾯量， 可在⼀般整数字⾯量后直接添加字母u或U,即使不带上u也可以,因为他们会被编译器默认转换。保险起见加上u。
Q1 : 为什么unsigned 可以显示负数?

```c
例如:
#include <stdio.h>
int main()
{
    unsigned int a = -100u;
    printf("%d\n",a);
    return 0;
}
#输出结果是-100
```

答: 之所以能显示-20是由于在printf的格式化参数中使用了%d, 该函数会首先将a转化为int类型。 如果格式化参数是%u,输出的是 为2^32-a.

2. short类型(短整型)
   
   **格式符:%hd,** 输入输出 short/unsigned short 时，不建议直接使用 int 的格式符 %d/%u 等，要加前缀 h

3. long 类型
   
   **格式符:%ld**;
   
   unsigned long对应的整数字⾯量是在 unsigned int字⾯量后⾯加上字母l或L. 因为long和unsigned long在不同环境下字节长度不同，所以我 们在定义⼀个整数对象时应当尽量避免使⽤long类型，除⾮涉及系统相关 的⼀些属性。

4. long long类型
   
   **格式符:%ll**;
   
   long long对应的整数字⾯量表⽰为int整数字⾯量后加后缀ll或LL

5. 布尔类型
   
   在C11标准中，布尔类型⽤关键字_Bool声明，并说明布尔类型只要能够存放0和1值就⾏，也就是⾄少为1个⽐特。0表示假.1表示真.
   
   ```c
   _Bool b = 0;
   ```

6. 字符类型
   
   有些编译器会默认将char设定为无符号，即char类型的整数是一个无符号的8位整数。当需要使用signed char时，signed不应该被省略。并且，在C11标准中，char、signed、unsigned char三者在类型上是不兼容的。

C语言中的转义字符

| 转义字符 | 意义                   | ASCII码值（十进制） |
| ---- | -------------------- | ------------ |
| \a   | 响铃(BEL)              | 007          |
| \b   | 退格(BS) ，将当前位置移到前一列   | 008          |
| \f   | 换页(FF)，将当前位置移到下页开头   | 012          |
| \n   | 换行(LF) ，将当前位置移到下一行开头 | 010          |
| \r   | 回车(CR) ，将当前位置移到本行开头  | 013          |
| \t   | 水平制表(HT)             | 009          |
| \v   | 垂直制表(VT)             | 011          |
| \'   | 单引号                  | 039          |
| \"   | 双引号                  | 034          |
| \\   | 反斜杠                  | 092          |

#### 5.2 浮点类型

在⼗进制浮点数后⾯添加f或F后缀，表⽰该字⾯量是float类型浮点数；不添加任何后缀 表⽰double类型浮点字⾯量；添加l或L后缀表⽰long double类型的浮点字⾯量。

1. C语言中还可以对浮点数使用科学计数法表示.
2. C语言中还可以用十六进制表示浮点数.例如:0x3p-1f,表示3x2^-1.

#### 5.3 数据精度与类型转换

1).任意两个不同类型的带符号整数不会具有相同等级，即使它们所表⽰的值⼀模⼀样。

例如:int = 123,long = 123,即使表示的数字是一样的,但是long的等级依然比int高.

2). ⼀个⽆符号整数类型的转换等级与其相应的带符号整数类型的等级相同.

1. 整数晋升
   
   在C语⾔标准中，之所以称为整数晋升是因为低转换 等级提升到⾼转换等级类型，在整数数据上不会有任何变化，⽽仅仅是类 型变为更⾼等级了。

```c
signed char c = -128;
    short s = c;
    int i = s;
    long l = i;
    long long g = l;
    printf("%lld\n",g);

    unsigned char uc = 100;
    unsigned int ui =uc;
    printf("%u\n",ui);
```

2. 带符号整数与无符号之间整数的转换
   
   当⼀个带符号（⽆符号）整数类型要转换为另⼀个⽆符号（带符号） 整数类型时，如果转换⽬标类型**有⾜够⼤的精度**来容纳原始类型，那么转 换后的值是保持不变的。
   
   a.高精度原始整数到低精度整数（无论是否带有符号）
   
   如果无法容纳, 原始整数值通过不断地加（或减）⽬标类型最⼤能表⽰的值再加1，直到该值恰好能落在⽬标⽆符号整数可表⽰范围内。 例如:

```c
short s = -129;
unsigned char uc = s;
/*
转换为unsigned char,unsigned char可表示的最大值为255.
则uc = -129+(255+1)=127
*/
```

但是,在计算机中, 直接将超出⽬标⽆符号类型的位全都舍去即可。⽐如，-129的16位⼆进制数为1111111101111111，如果将它转 换为8位⽆符号类型，那么我们直接将⾼8位舍去，取其低8位作为⽬标⽆符号8位整数类型即可，所以转换后的结果就是01111111，即0x7F，对应于⼗进制数127。

b.低精度整数到高精度整数

**带符号：**先判断原始低精度整数的符号位（左边第一位就是符号位），如果是0（表⽰⾮负整数），则⽤0填充到⾼精度⽆符号整数；如果是1（表⽰负整数），那么⽤1填充到⾼精度⽆符号整数。

**不带符号：** 高位添0
3. 浮点数之间的转换以及浮点数和整数之间的转换

1).依据IEEE754规格化浮点表示法，大多都胡十进制无法精确的使用二进制浮点数表示，这是由于尾部部分其实商用的是2的n次方进行相加拟合而成的。因此：再比较两个浮点数时候，要慎用==等一些操作符。

2).double转float的符号位以及尾数高位不用变动，在末尾添加0即可。但是float转double可能会导致精度丢失。

3).浮点数转为整数,结果是未定义的.

#### 5.4 运算操作符

1. 复合函数操作符: +=、-=、*=、/=、%=

2. 按位逻辑操作符
   
   按位与、按位或、按位异或以及按位取反，在C语⾔中的 操作符分别对应为：`&`、`|`、`^`、`~`。 赋值操作: `&=`、`|=`、`^=` .

```c
_Bool b = 1;
    printf("0x%x\n",~b);
    //输出结果是:0xff,这是因为0被存储为0000 0000,取反后变成1111 1111,即可用16进制表示为0xff.
```

3. 自增、 自减
   
   前缀++或--:先进行+(-)的操作,再赋值.

```c
int a =2;
    int b = ++a;        //自加: 等价于 int b = a;    a+=1;
    int c = --b;        //自减: 等价于 int c =b;     b-=1;
    printf("a=%d,c = %d\n",a,c);    //输出:a=3,c = 2
```

后缀++或--:先赋值,再进行+(-)操作.

```c
int d =2;
    int e =d--;
    printf("d=%d,e=%d\n",d,e);      //输出结果d=1,e=2
```

4. 关系操作符、相对性操作符、逻辑操作符
   
   关系：`>`     `<`     ` <=`     `>=`
   
   相等性:`==`    `!=`
   
   逻辑操作符:`&&`表示且,`||`表示或,`!`表示非
   
   `&&`和 `||`都是双目操作符,判断顺序都是从左往右,但是&&会判断两边,都为真,结果才为真,若 `||`左边为真,既不会判断其右边的内容.`!`是一个单目操作符,

5. 移位操作符
   
   `>>`和 `<<`都是双⽬操作符，并且其左右操作数都必须是整数类型, a>>b表⽰对整数a向右移b位。
   
   1).尽量避免移位的右操作数为负数的情况，以及右操作数的数值⼤于等于左操作数位宽的情况。
   
   2).算术右移与逻辑右移: 如果左操作数是带符号整数类型，那么采⽤的是算术右移；如果是⽆符号整数类型，那么采⽤的是逻辑右移。

```c
int a = -10;
    unsigned b = 0xfffffff6;        //-10的十六进制
    a >>=30;        //a有符号,算术右移
    b >>=30;        //逻辑右移
    printf("a :%d   b:%d\n",a,b);       //输出:a :-1   b:3
```

6. 圆括号操作符
   
   主要用于提升优先级.

#### 5.5 sizeof操作符

`sizeof()`用于返回操作数占多少个字节.

```c
int a = 10;
    size_t size = sizeof(a);
    printf("%d\n",size);
```

#### 5.6 投射操作符

1).语法: 在圆括号中放上类型名，⽤于修饰⼀个表达式。它与圆括号操作符的区别在于，圆括号操作符中是将表达式作为其操作数；⽽投射操作符则是在圆括号中放类型名。

2).含义: 将⼀个表达式的类型投射为该投射操作符所指定的类型.涉及的动作:通过拷贝元对象,生成一个临时的新对象, 后续的操作都是对临时对象进行的.

3).注意:

a.投射表达式不可为左值.(投射表达式不会产生左值)

b.投射表达式不可以做自修改操作

### 6 *用户自定义类型

#### 6.1 枚举类型

```c
enum 枚举标识符 {枚举符列表};
//例如:
enum DAY
{
    MON=1,
    TUE,
    WED,
    THU,
    FRI,
    SAT,
    SUN
};
```

注意:

1.当前主流C语言编译中,枚举类型默认与int类型兼容.

2.枚举类型被当作int或unsigned int,所以无法被遍历.但在枚举类型是连续的条件下是可以遍历的.

*枚举变量的定义.

```c
#1.先定义枚举类型,再定义枚举变量
enum DAY
{
    MON=1,TUE,WED,THU,FRI,SAT,SUN
};
enum DAY day;
#2.定义枚举类型同时定义枚举变量
enum DAY
{
    MON=1,TUE,WED,THU,FRI,SAT,SUN
}day;
#3.省略枚举名称
enum
{
    MON=1,TUE,WED,THU,FRI,SAT,SUN
}day;
```

#### 6.2 结构体类型

1.结构体中可以存储不同类型的数据项.

```c
struct 标识符(可省略) {结构体声明列表};

#示例
struct StrucTest;        //声明一个StructTest结构体
enum MyEnum
{
    MY_Enum1,
    MY_Enum2
};
struct MyStruct
{
    int32_t a;
    enum MyEnum e;
    double d;
}
```

2.用结构体创建对象并访问成员

```c
#include <stdio.h>
static struct MyPoint
{
    float x,y;  
}g_point;

int main()
{
    struct MyPoint point;
    printf("g_point.x = %.2f , g_point.y = %.2f\n",g_point.x,g_point.y);  
    //符号"."是访问操作符。
    printf("point.x = %.2f , point.y = %.2f\n",point.x,point.y);  
    //g_point与point 两者等价

    struct MyPoint point2 = {100.0f,50.0f};     //初始化操作
    printf("point2 = %.3f, point2 = %.3f\n", point2.x,point2.y );
    return 0;
}
```

3.结构体复合字面量

```c
#include <stdio.h>
#include <stdint.h>
int main(){
    struct S
    {
        int32_t a,b;

    }s;
    s = (struct S){.a = 100, .b = 120};     //这就是一个结构体复合字面量
    printf("s.a = %d,s.b = %d\n ",s.a,s.b);   
    return 0;
}
```

和初始化操作很相似,其实就是在初始化器{}左边加上对该结构体的投射操作.

#### 6.3联合体类型

联合体的声明形式与结构体类似，也可以存放其它类型的对象, 但是与结构体不同的是，联合体对象中的所有成员共享同⼀存储区域。

注意: 联合体与结构体⼀样，不能⽤作投射操作符所指定的类型；联合体对象不能直接使⽤关系操作符来⽐较⼤⼩、判断是否相同等

```c
//union 标识符(可省略) {}; 
//示例:
#include <stdio.h>
#include <stdint.h>
int main()
{
    union
{   
    int8_t a;
    int16_t b;
    int32_t c;
}u = {.c = 0x04030201};
    printf("a:0x%x\tb:0x%x\tc:0x%x\n", u.a,u.b,u.c);
    //输出结果:a:0x1   b:0x201  c:0x4030201
    return 0;
}
```

#### 6.4 位域

位域可以将一串比特流进行结构化描述.

1. 特性
   
   1). 如果结构体中的某一个成员要作为位域,那么它必须是一个整数类型.

```c
/*
基本表达式: <类型> <标识符>:<位宽标识符>;
位宽标识符用来指定此区域的宽度, 单位是比特
*/
struct BitField
{
    int32_t a: 5 //a由五个比特构成,取值范围[-16,25]
    int32_t b: 6 //b由六个比特构成,取值范围为[0,63]
}
```

2). C语言对位域的限制:

a.不能对位域成员取地址

b.位域成员不可以做为sizeof的操作数

c.不能用对其属性来修饰位域

d.指定位域宽度的常量值不能超过该类型可表示的范围
2. 位域成员的存放和布局

存放:若存放单元的存储空间够,后一个位域成员会和前一个位域成员存放在同一单元, 若空间不够, 存放位置可以由自己定义.
3. 匿名位域

当某个位域只给出其类型及宽度，⽽不给出标识符名时，该位域则称为匿名位域。匿名位域⼀般仅⽤作⽐特填充（通常C语⾔的实现都⽤0来填充），⽽不能被直接访问该填充区 域。⽽当匿名位域的宽度为0时，则表⽰该位域是其前⾯的位域所组成的存储区域的末尾，即作为⼀个结束标志⽽使⽤。

*使用:在实际中,往往把需要的拼接在一起的位域成员用相同的类型或相同的字节宽度的类型相邻排放,比表面不必要的填充.

```c
#使用示例
#include <stdio.h>
#include <stdint.h>
int main(){
    struct  Student
    {
        uint16_t grade : 2;        //年级1-3
        uint16_t class : 4;        //班级:一个年级最多16个班级
        uint16_t number : 7;       //学号:一个班级最多128个学生
    };
    struct Student s = {1,3,5,};
    printf("size is :%zu\n", sizeof(s));
}
```

#### 6.5 字节对齐与字节填充

一个函数的起始地址以及⼀ 个数据对象的起始地址都会是4字节的倍数（⽐如地址0x01001000， 0x00400204等）.

1. _Alignof操作符:
   
   1). _Alignof与sizeof类似,但有两点不同: sizeof后不要圆括号,但是__Alignof则不行.
   
   2). _Alignof的操作数只能是类型名(基本类型、枚举类型、结构体、联合体)，而不能是一个表达式（包括对象标识符）

2. _Alignas 对齐说明符
   
   类型默认对齐以及_Alignof操作符的使⽤。但在很多情况下，通过编译器的默认对齐⽅式⽆法满⾜对齐要求，尤其涉及⾼性能计算领域时，我们可能要将⼀个结构体或⼀个数组以16字节对齐甚⾄64字节对齐的⽅式存放。

注意：

a.不小于当前C语言实现默认对齐的大小。

b. _Alignas的操作数应该是0、1、2、4等⽆符号整数。当其操作数⼤于4时，该操作数必须是4的倍数，否则编译器可能报错。

c. 编译器实现⼀般都会对对齐说明符指定⼀个最⼤可对齐的字节数， 在Apple LLVM编译器中指定为256MB，如果_Alignas的操作数的值超过 256×1024×1024，那么编译器将会报错。

```c
//使用示例:
#include <stdio.h>
#include <stdbool.h>
#include <stdalign.h>

int main(){
    int a1 = 0;
    size_t align = alignof(a1);
    printf("a1 alignment is %zu\n",align);

    int _Alignas(double) a2 = 0;
    //用double对齐属性给int类型a2作字节对齐,_Alignas可以放在类型的后面, 对象标识符的前面
    align = alignof(a2);
    printf("a2 alignment is %zu\n",align);

    //从int、double、64字节对齐这三种对齐方式中，选取最大字节最为对齐要求
    alignas(int) alignas(double) alignas(64) int a3 = 0;
    align = alignof(a3);
    printf("a3 alignment is %zu\n",align);

    //指定为0的对齐，那么它仍然采用默认对齐方式
    double alignas(0) d = 0;
    align = alignof(d);
    printf("d alignment is %zu\n",align);

    //判断后再对齐
    long long alignas (alignof(long long ) >8 ? alignof (long long ):8)
    ll = 0ll;
    align = alignof (ll);
    printf("ll alignment is %zu\n",align);

    //对齐符号也能修饰一个结构体
    struct MyStruct
    {
        int alignas(16) a;
        int b;
    }s = {0,0};
    printf("s size if %zu\n",sizeof(s));
    printf("s alignment is %zu\n",alignof(s));

    return 0;
}
```

3. 结构体成员的字节对齐与字节填充
   
   #规则:
   
   1）结构体第⼀个成员所在的偏移地址为0（即从0开始计）。
   
   2）每个成员根据其类型或程序员指定的对齐字节数来判定它所在的偏移地址。如果该成员要求4字节对齐，那么它所处的偏移地址就应该是4的倍数，如果不是4的倍数，则向上取不⼩于当前偏移值的4的倍数的最⼩整数。
   
   3）确定了当前成员对象的偏移地址之后，它的起始地址到前⼀个对象 之间空⽩的存储空间⽤0来填充。
   
   4）结构体对象的字节对齐要求与其成员中最⼤字节对齐要求相⼀致。

#### 6.6 复数类型

在C语言中,也由实部和虚部构成, 在使用的时候一定要包含头文件<complex.h>

```c
//使用示例
#include <stdio.h>
#include <complex.h>

int main()
{
    float _Complex comp = 3.0f+0.5fi;
    comp += 5.4f;       //对实部进行操作 
    comp += 0.3fi;      //对虚部进行操作

    float r = crealf(comp);     //获取实部
    float i = cimagf(comp);     //获取虚部

    printf("%.2f+%.2f\n",r,i);

    comp = 100;  
    //将一个实数赋值给复数, 则是将整数100转换为float类型,并赋值给复数的实部部分,虚部部分为0
     printf("%.2f+%.2f\n",crealf(comp),cimagf(comp));
    return 0;
```

注意:

1). 复数的实部和虚部都只能是float 、double、long double

2). 复数可以像实数一样, 通过加减乘除进行计算; 复数之间不能判断大小, 但是可以比较是否相同.

3). 负数在转换为实数时候,虚部被舍去.

### 7 数组和指针

#### 7.1 一维数组

一个具有相同类型的多个元素的有序组合.

```c
//格式: 类型名 对象标识符 [数组元素个数]
#include <stdio.h>
#include <stdint.h>
int main()
{
    char c[5] =  {'a','b','c','d','e'};     //例如, 创建一个数组并初始化
    printf("%c\n",c[3]);

    int32_t a[4] = {100,-1};
    printf("%d  %d  %d  %d\n",a[0],a[1],a[2],a[3]);
    //输出结果:100  -1  0  0

    float f[5] = {[1]=0.5f,[4] = 0.89f};
    printf("%f  %f  %f  %f  %f\n",f[0],f[1],f[2],f[3],f[4]);
    //输出结果:0.000000  0.500000  0.000000  0.000000  0.890000

    int32_t b[] = {c[0],a[0],f[1]};     //初始化时,依据元素个数来确定长度
    printf("%d  %d  %d\n",b[0],b[1],b[2]);

    int32_t d[3];       //这里没有初始化
    d[0] = b[2];
    d[1] = b[1];
    d[2] = b[0];
    printf("%d  %d  %d  %d\n",d[0],d[1],d[2]);
    return 0;
}
```

*注意:

1).  不能将⼀个数组对象直接赋值给另⼀个数组对象，即便对⼀个数组对象进⾏初始化时也同样如此 ;但是也有例外, 例如匿名数组对象可以在对某个数组初始化时候直接赋值.

2). 使用匿名数组初始化时候,类型必须要匹配.


#### 7.2 多维数组

#### 7.3 变长数组

这类数组在声明时，其元素个数不是⽤常量表达式来指定的，⽽是**通过变量**。因此变长数组不能在⽂件作⽤域中声明，不能⽤static存储类说明符来修饰。此外，变长数组以及指向变长数组的指针类型统称为**可变修改类型**.

*应用场合:  要在⼀个函数内部定义⼀个数组，但其⼤⼩需要通过函数参数来指定，且元素个数也不会 太多。

```c
#include <stdio.h>
int main ()
{
    int a =5;
    int b[a];
    ++a;
    printf("size of b:%zu\n",sizeof(b));
    //尽管a增加为6，但是数组b的的大小仍为20，b的大小声明时候已经不确定了

    int x = 0;
    int (*p)[a] = &b;       //指针p指向数组b的地址
    printf("size of b:%zu\n",sizeof(*p));        //这里*p的大小为修改后b[a]的地址

    return 0;
}
```

#### 7.4 一级指针与对象地址

1. 基本概念
   
   格式: 在对象标识符前添加*号就能把它声明为⼀个指针对象,在表明是一个类型时候会与类型紧贴

注意:

```c
//int *p =&a;
//sizeof(int*);
#include <stdio.h>
int main ()
{
    int a = 10;
    int *p = &a;
    printf("p value is : %d,size is :%zu\n",*p,sizeof(p));
    printf("address of a :0x%.8x\n",&a);
    printf("address of *p :0x%.8x\n",&*p);
    //输出结果:address of a :0x0061ff1c,address of *p :0x0061ff1c,指针对象p指向了a
     printf("addess of p :0x%.8x\n",&p);
    //输出结果: addess of p :0x0061ff18,指针对象本⾝也有它⾃⼰的地址
    *p = 34;

    return 0;
}
```

2. 访问指针对象所指对象的内容
   
   指针对象指向了某一个对象后可以使用间接操作符 `*`, 间接访问指针指向对象的值.

```c
#include <stdio.h>
int main ()
{
    int a = 10;
    int *p = &a;
     *p = 29;
     printf("a value is: %d\n", a);
       //这里a的值变为了29,因为计算机所做的操作是:：⾸先获得指针对象p的值；然后以这个值作为地址，把20写⼊到这个地址中去。
    return 0;
}
```

3. 指针对象的其他操作
   
   1). 大小比较: 两个指针对象是可以比较大小的, 比较的是所指对象的地址大小, 例如: 0x00007FFF5FBFF800要⼩于 0x00007FFF5FBFF80C
   
   2). 类型转换 :不同类型的指针通常不可以做隐式转换. 例如: `int*`和 `short*`是无法做隐式转换的, 必须通过投射操作进行显式转换, 否则会报错.
   
   ```c
   #include <stdio.h>
   #include <stdbool.h>
   #include <stdint.h>
   
   int main ()
   {
       int32_t a =10,b=10;
       int32_t *p = &a,*q = &b, c = 0, *r = &c;
   
       //指针可以比较大小以及是否相等
       bool e = p >q;
       printf("is p > q?%d\n", e);
       e = p ==r;
       printf("p == r?%d\n",e);
   
       //int32_t *t;      //这里会因为类型int32_t与int16_t不匹配而报错！！故被注释
       int16_t s = 1, *t = &s;
       t = (int16_t*)&a;
       /*
       如果需要让指针t指向a，可以用投射操作符来强制转换，
       且不会有编译错误，但并不建议这么使用，因为若写入超过int16_t范围的数，将可能会导致错误
       */
       return 0;
   }
   ```
   
   注意:
   
   1). 取地址操作符与间接操作相互抵消
   
   ```c
   b = *&*&a; //等价于b = a;
   ```
   
   2). 存放指针或地址值的最佳类型是uintptr_t
   
   3). 会引起错误的表达式
   
   ```c
   &b++; &++b; &1234; &sizeof(b); &&a;
   ```
   
   4). 指针和整数可以通过投射操作符来相互转换
   
   5). 可通过投射操作符给一个指针赋特定值
   
   ```c
   int *p = (int*)0x00ff01000;
   ```

#### 7.5 多级指针

在声明⼀个指针对象时，`*`号表⽰该对象为多少级的指针对象；在表达式中，*号作为单⽬操作符使⽤时就是间接操作，表⽰以它的操作数的值作为地址，取该地址中的内容。

```c
#include <stdio.h>
#include <stdint.h>

int main ()
{
    //**pp = 30过程分解
    int a=10;
    int *p = &a;
    int **pp = &p;
    //第一步：获取pp所指对象的地址；用address1保存
    uintptr_t address1 = (uintptr_t)pp;
    //第二步：以address1为地址,访问其内容,然后将地址保存为address2, 这里相当于执行了第一次间接操作
    uintptr_t address2 =*(uintptr_t*)address1;
    //第三步:  最后以address2为地址, 将30写入其中
    *(int*)address2 = 30;
    //最早输出结果
    printf("a = %d\n",a);
    return 0;
}
#### 7.6 指定用户自定义类型的指针

对于⼀个普通 的结构体对象要访问其成员时，我们使⽤`.`操作符。⽽如果我们要通过⼀个指向结构体类型的指针去访问它所指的结构体对象的成员时，我们必须使⽤`->`成员访问操作符。
```c
#include <stdio.h>
int main ()
{
    enum LIGHT
    {
        RED_LIGHT = 119,YELLOW_LIGHT = 20,GREEN_LIGHT=66
    }light,*pe = &light;
    //声明一个对象light, 以及指向枚举类型的指针对象pe
    *pe = YELLOW_LIGHT;
    printf("light = %d\n",*pe);

    struct S
    {
        int a ;
        float f;
        enum LIGHT *pe;
    }s,*p = &s;
    p -> a = 10;
    p -> f = 2.34f;
    p -> pe = &light;

    printf("a = %d, f =%f, light = %d\n", s.a,s.f,*pe);
    //成员访问符' . '和 '->'优先于间接操作符' *'
    *p->pe = RED_LIGHT;      //*p->pe等价于 *(p->pe)
    printf("light = %d\n",*p);
    struct S s2 = *p;
    printf("a = %d, f =%f, light = %d\n", s2.a,s2.f,*pe);

    struct S **pp = &p;     //声明一个指向结构体的二级指针对象pp, 用p的地址对他初始化
    (*pp) -> a = 13;
    (**pp).f = 3.293f;
    *(*pp) -> pe = GREEN_LIGHT;
    printf("a = %d, f =%f, light = %d\n", s.a,s.f,*pe);
    return 0;
}
```

#### 7.7 指针与数组

1. ⼀个数组对象能合法地隐式转为相应的指针类型。⽐如，⼀个int[5]类型能被转为int*类型， 使得⼀个指针对象能指向⼀个数组的某⼀元素的地址。

```c
#include <stdio.h>
#include <stdint.h>

int main ()
{
    int32_t a[5] = {0,1,5};
    int32_t *p = &a[0];
    printf("a[0] address:0x%.8x\n",p);
    p = &a[1];
    printf("a[1] =%d\n",*p);
    p ++;//对其某个元素做取地址操作就相当于从该数组⾸地址加上指定元素所在的偏移地址。
    // 或p = &a[2];
    printf("a[2] address:0x%.8x\n",&p);
    printf("a[2] =%d\n",*p);
    p = a;      //将p重定向到a的起始地址
    p[3] +=10;
    printf("a[3] =%d\n",a[3]);
    return 0;
}
```

2. 指针与数组的关系及算术运算
   
   指针对象只能加减法, 不能乘除法, 并且两个指针之间或一个指针与整数之间也无法进行按位运算.

```c
#include <stdio.h>
#include <stdint.h>

int main ()
{
    int32_t a[5] = {1,2,3,4,5};
    int32_t *p = a;

    //打印p的值(也就是数组a的首地址)
    printf("a address: 0X%.8X\n",p);
    printf("p =  0X%.8X\n",&p);

    p = &a[1];       //索引操作符[]优先于取地址&符

    uintptr_t address = (uintptr_t)p;       //存放指针对象p的地址
    p = a;      //p重新指向a的起始位置
    p[3]+=10;       //*(p+3) += 10;         //取指针指向的a[3]的值再加10
    printf("%d\n",a[3]);

    p = a +1;
    int *q = &a[3];
    printf("q address:0x%x,p = address : 0x%x\n",&q,&p);
    printf("q - p = %d\n",q - p);  
    //两个指针之间可以作加减, 这里说明两者跨越了两个元素

    //用于与上方效果对比
    int *j;
    int *k;
    printf("j address:0x%x,k = address : 0x%x\n",&j,&k);
    printf("j - k = %d\n",j - k);

    int32_t* array[5] = {p,q,a};  
    //每个元素的类型是int32_t* ,array[4]和array[3]为空

    printf("array[0][0] = %d\n", *array[0]);
    printf("array[0][0] = %d\n", **array);      //这三种方式均可
    printf("array[0][0] = %d\n", array[0][0]); 
    return 0;
}
```

注意:

1). 数组对象类别虽可被隐式转换为指针对象类别, 但是仍是不同的类别.

2). 指针无法被转换为数组类型, 即使是投射操作符也不行.

3). 当整数与指针加减时, 指针的值相当于加减该整数的sizeof(*该指针对象的)该整数倍;

当两指针相减(两指针无法相加), 结果是两指针的差值除以sizeof(*该指针对象).

#### 7.8 指向数组的指针

1. 指向一维数组的指针

```c
#include <stdio.h>
  #include <stdint.h>

int main ()
{
    int a[] = {1,2,3,4,5};
    int *p = a;
    //声明一个指向int[5]数组类型的指针对象, 并用数组a的地址对他初始化
    int (*pa)[5] = &a;
    printf("size of (*pa):%zu\n",sizeof(pa));

    int sum = 0;
    for (int i = 0;i <5;i++)
        sum +=(*pa)[i];
    printf("sum = %d\n",sum);

    int b[3][5] = {
        {1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15}
    };
    pa = b;
    pa[0][0]++;
    (*(pa + 1))[0]--;
    printf("b[0][0] : %d, b[1][0] : %d\n",b[0][0],b[1][0]);

    uint64_t address = (uint64_t)pa;
    pa +=1;     //相当于pa = &b[1]
    address+=sizeof(b[0]);
    printf("address = pa?  %d\n",(uint64_t)pa == address);

    int n =a[2];
    //声明一个变长数组
    int v[n];
    //a[2] = 3
    v[0] = 1,v[1] = 2,v[2] = 3;

    int (*pv)[n] = &v;

    n++;
    printf("n = %d\n", n);
    //v的元素个数依旧是3
    printf("size of (*pv) is: %zu\n", sizeof(pv[0]));
    printf("size of v is: %zu\n", sizeof(v));

    int (*pv2)[n] = pv;
    //v的元素个数变为了4
     printf("size of (*pv2) is: %zu\n", sizeof(pv2[0]));

    return 0;
}
```

注意:

1). `int *p`指向了对象a的首个元素, `int (*pa)[5]`指向了数组a的地址(或者说用a的地址对他初始化),  地址虽然相同,但是概念和含义是不同的.

2. 指向二维数组的指针
   
   ```c
   #include <stdio.h>
   #include <stdint.h>
   
   int main ()
   {
       int a[2][3] = 
       {
           {1,2,3},{4,5,6}
       };
       int (*p) [2][3] = &a;
       //修改二维数组的值
       (*p)[0][0] +=10;
       printf("a[0][0] = %d\n", a[0][0]);
        //修改二维数组的值
       p[0][1][2] +=100;
       printf("a[1][2] = %d\n", a[1][2]);
   
       printf("size of *p:%d Byte\n",sizeof(*p));
       return 0;
   }
   ```

#### 7.9 void类型、指向void类型的指针和空指针

1. void一般用于函数返回类型以及表示空的形参列表，也可以作为表达式的类型， 表示该表达式不返回任何值、也不具有任何有意义的类型. 但可以通过投射强转.

```c
//第一种
  (void)0,(void)1;
  //第二种
  (void)(void)(1+2);
  //第三种(三目操作符)
  1 >2 ?(void)0:(void)1;
```

2. 如果一个指针对象是指向void类型的指针, 那么该指针可以被隐式转换为任意对象类型的指针. (故void*指针类型也被叫做万用指针类型)

```c
#include <stdio.h>
int main ()
{
    int a= 10;
    void *p = &a;
    int *q = p;
    *q+=10;
    printf("a = %d\n",a);

    //将void类型的指针p指向临时数组的地址
    p = &(int[]){1,2,3};
    //直接将p转换为指向int[3]数组的指针类型, 并对该数组索引为1的元素+2
    ((int(*)[3])p)[0][1] +=2;
    //这里不再需要投射操作符
    int (*t)[3] = p;

    q = *t;
    printf("q[1] = %d\n",q[1]);
    return 0;
}
```

注意:

1).  通常, 不能对一个空指针所指的内容进行读写. `int*p = NULL`,这里p就被初始化一个空指针.

2). 野指针(wild pointer): 局部声明一个指针时, 如果没有对他进行有意义的初始化, 那么该指针指针对象的值是不确定的, 就被称之为野指针, 是不受控的地址. 用空(NULL)来标识该指针为无效指针, 那么更易于处理, 所以此类情况可以让指针指向空.

#### 7.10 字符数组与字符串字面量

1. 部分特性

```c
#include <stdio.h>
#include <string.h>
int main ()
{
    const char *ascii_string = "Hello, World!";
    printf("ascii_string: %s\n",ascii_string);
    //utf8
    const char *utf8_string = u8"你好!";
    printf("utf8_string: %s\n",utf8_string);

    //用字符串字面量直接给一个字符数组初始化
    char s[] = "abc";
    //s[]与"abc"地址是不同的
    printf("address of s: 0x%.16x\n",&s);
    printf("adress of  'abc' :0x%.16x\n",&"abc");
    //除了"abc"外,还有结束符"\0",所以长度是4 Byte
    printf("size of s:%zu Byte\n",sizeof(s));

    char a[] ={'a','b','c','\0'};
    //用strcmp库函数来比较两个字符串数组内容是否相同
    //返回0表示相同, 返回负数说明s小于a
    int equal = strcmp(s,a);
    printf("Result is %d\n",equal);
    return 0;
}
```

2. 拼接特性

```c
#include <stdio.h>
int main ()
{
    const char *s0 = u8"a" "b" "c";
    const char *s1 = u8"d" "e";
    printf("s = %s%s\n",s0,s1);
    return 0;
}
```

注意:

1).  ⼀个字符串字⾯量会⾃动添加⼀个'\0'字符，⽤来表⽰该字符串的结束符。该结束符可被库函数strlen等使⽤，⽤于获取当前字符串的长度（即字 符个数通常也实现为字节个数).

2). 字符串字面量虽然是数组类型, 但相比较数组的语法体系还有例外特征. 经过字面量的类型是一个字符数组类型, 且不是常量.

#### 7.11 完整与不完整类型

不完整类型:缺乏足够信息去判断该类型所声明对象的大小.

1. void: void表达式表示不存在的值, 该类型就是不完整类型, 不能转换为其他类型(显式和隐式都不可以), 如果计算结果为一个void表达式, 计算结果及其标识符会被丢弃, 不能给任意对赋值.

```c
(void)(2+3)    //不能给任何对象赋值
```

2. 枚举、结构体、联合体标识符：因为他们没有任何信息描述自己.
3. 指向不完整类型的指针是一个完整类型, 因为指针类型大小是确定的.

```c
#include <stdio.h>

//由于缺乏对该类型的明确定义, 因此当前翻译单元这个位置, 是一个不完整类型
struct Mystruct;
static void foo()
{
    //struct Mystruct* 是一个完整类型
    //写struct Mystruct s;将会报错, 因为一个不完整类型不能用来声明该类型的对象
    struct Mystruct *p = NULL;
    printf("size of %zu\n",sizeof(p));
    return (void)(2+3);
}
//这里对Mystruct进行了明确的定义, 是一个完整类型
struct Mystruct
{
    int i;
    float f;

    //但在此时(已经定义的结构体内部)仍是不完整类型,但可以定义指向Mystruct结构体类型的指针对象作为成员
    struct Mystruct *p;

    //如果结构至少含一个命名成员对象, 那么最后可以更一个不指定大小的数组
    //最后不指定大小的数组对象也是一个不完整类型, 但是数组元素的类型必须是完整的
    //array 不占Mystruct结构体的大小
    void* array[];  
};

int main()
{
    //foo();
    struct Mystruct s = {10,1.23f};
    printf("s.i : %d    s.f:%.2f\n",s.i,s.f);
    printf("size of %zu\n",sizeof(s));
    return 0;
}
```

4. 由于⼀个不完整类型⽆法确定其⼤⼩，因此它不能作为sizeof、 _Alignof的操作数 .

#### 7.12 灵活的数组成员

灵活数组成员: 不指定数组长度.

在⼤部分情况下，灵活的数组成员是**被忽略**的，⽽结构体的⼤⼩也**不把**灵活的数组成员给算进去，但是字节填充会受到灵活的数组成员类型的影响。当我们⽤“.”或“->”成员访问操作符去访问灵活的数组成员时，该成员的偏移量往往就是结构体⾃⾝⼤⼩。

```c
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
int main()
{
    struct Test1
    {
        int8_t b ;
        double d[];
    };

    //获取成员d所在Test结构体中偏移量
    size_t offset = offsetof(struct Test1,d);
    printf("offset is %zu\n",offset);
    printf("size of struct Test1: %zu Byte\n",sizeof(struct Test1));

    struct Test2
    {
        int a;
        //array是灵活数组成员，由于array所在的偏移位置正好与int对齐， 因此整个结构体Test2无需做字节填充
        int array[];
    };
    printf("size of struct Test2 %zu Byte\n",sizeof(struct Test2));

    
    /*
    ⽤“.”或“->”成员访问操作符去访问灵活的数组成员时，该成员的偏移量往往就是结构体⾃⾝⼤⼩。 
    当我们访问ts数组中第一个元素array成员时候，array正好指向第二个元素的起始地址
    */
    printf("sum = %d\n",sum);

    struct Test2 *pt = malloc(sizeof(*pt)+sizeof(double[sum]));
    for (int i = 0;i < sum ; i++)
        pt ->array[i] = i +1.0;
    double result = pt-> a;
    for (int i = 0;i <sum;i++)
        result +=pt ->array[i];

    printf("result is %.2f\n",result);
    return 0;
}
```

### 8 控制流语句

#### 8.1 逗号表达式

逗号操作符优先级较低, 通常需要用 `()`使它们不被其他操作符分割

```c
#include <stdio.h>
int main()
{
    int a,b;
    //相当于b = 3, a = 4;
    a = (b=3,4);
    printf("a = %d,b = %d\n",a,b);
    a = (b++,4);
    printf("a = %d,b = %d\n",a,b);
    return 0;
}
```

#### 8.2 条件表达式

```c
//布尔表达式?表达式1:表达式2
//布尔值为真执行表达式1
#include <stdio.h>
int main()
{
    int a = 10;
    int b;
    //条件表达式的 ? 优先级高于赋值符号, 所以后一个表达式需要加括号
    //否则将被识别为:  (a > 0?b = 1:b )= -1;
    a > 0?b = 1:(b = -1);
    printf("b = %d\n",b);

    //等价于b = a -10;
    b =a <0?a +10:a-10;
    printf("b = %d\n",b);
    return 0;
}
//特别注意:使用时需要看是否有赋值运算符,有赋值运算符时候要注意加括号
```

#### 8.3 if-else语句

```c
#include <stdio.h>
int main()
{
    int a = 10,b = 0,c = 1;
    //if 内只有一条语句
    if (a>0)
        b = -1;
    //无论 a >0的结果是真还是假, b++都会执行, 因为在没有else且出现分号";"时, if-else语句已经结束
    b++;
    //if内有多条语句
    if (a==1)
    {
        c++;
        b++;
    //该处"}"后不加";" 否则会导致if与else被分割开
    }
    else
    {
        a = 0,b=0,c =0;
    };
    printf("%d  %d  %d\n",a,b,c);
    return 0;
}
```

#### 8.4 switch-case语句

```c
#include <stdio.h>
int main()
{
    int a= 2,b = 3;
    switch(a+3)
    {
        //可以声明对象
        int c;
        //但表达式不被执行
        printf("%d\n",c);
        case 2:
            b +=2;
            break;
        case 3:
            b +=3;
            break;
        default:
            b = 100;
            break;
    };
    printf("%d\n",b);
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    //空switch选择语句
    int a = 0;
    switch(a);
    switch(a)
    {
        //case下的空语句
        case 0:
            ;
       //default下的空语句
        default:
            ;
    };
    return 0;
}
```

注意:

* `switch()`选择语句中的表达式应该具有一个整数类型, 二八年时其他类型.
* 最多只允许有一个`default`, 表示没有值与`case`标签相匹配时执行.
* `default`与`case`标签下的语句不能声明一个临时变量,因为若声明一个临时变量, 在整个`switch`语句块作用域内, 对其他`case`也是可见的, 但执行到该区域时, 其值可能未被正确初始化.  不要在⾮`case`或`default`标签语句下使⽤任何表达式, 因为不会被执行.
* 'case'过于复杂时要用`{}`.

#### 8.5 while和do-while迭代语句

* while 语句

```c
#include <stdio.h>
int main()
{
    int a = 0,b = 10,c =5;
    while (c >0)
    {
        a++;
        b--;
        c--;
    };
    printf("%d  %d  %d\n",a,b,c);
    return 0;
}
```

注意:continue⽤于直接跳转到while表达式处做判别执⾏，⽽break则表⽰跳出当前循环体。

```c
//数组中元素倒序
#include <stdio.h>
int main()
{   
    int array[] ={1,2,3,4,5};
    int length = sizeof(array)/sizeof(array[0]);
    int a = 0;
    while (a <length/2)
    {
        int temp = array[a];
        array[a] = array[length-1-a];
        array[length-1-a] = temp;
        a++;
    };
    printf("array elements:\n");
    a = 0;
    while(a < length)
    {
        printf("%d  ",array[a]);
        a++;
    };
    printf("\n");
    return 0;
}
```

* do-while
  
  do-while先执⾏循环逻辑，然 后再通过while来判断当前表达式的真假情况。

```c
#include <stdio.h>
#include <stdbool.h>
int main()
{
    int a=0,b=0,c=0;
    do
    {
        //do中声明的对象,外部无法访问(while循环同理)
        int tmp =  a+1;
        a++;
        c++;
        //会跳转到while表达式处, 并且不执行continue后的内容(while循环同理)
        if (c <3)continue;
        b++;
        //跳出循环体(while循环中同理)
        if (c >4)break;
    }
    while(c<5);
    printf("%d  %d  %d\n",a,b,c);

    //空的do语句. do后必需有while
    do;
    while(false);
    return 0;
}
```

#### 8.6 for迭代语句

```c
//形式:for(子表达式;表达式2;表达式3){语句};
```

其中子表达式可以是一个声明, 也可以是一个表达式, 只执行一次, 不会迭代.;表达式2用于判断循环条件为真, 若满足就执行for循环,否则推出循环,若缺省则循环条件一直为真;执行完一次迭代之后就会执行表达式3.

```c
#include <stdio.h>
int main()
{
    //i 无法在循环外被调用
    //{}中若只有一句,可去掉大括号
    for(int i = 0;i < 10;i++)
        printf("%d  ",i);
    /*for()括号中的语句都可以省略
    for(;;)
        printf("*");
    */
    printf("\n");
    for(int j = 0;j <=10;j++)
    {
        if(j == 3)continue;
        printf("%d  ",j);

    };
    printf("\n");
    return 0;
}
```

注意:

* `break;`跳出循环,`continue;`是跳转到表达式3.

#### 8.7 goto语句

注意:

* 使用goto语句前必须确保对象被初始化
* goto可能会导致一些未知问题,一般不建议使用

```c
#include <stdio.h>
int main()
{
    int a,b;
    a=7,b=9;
    if (a>b)
        //跳转到NEXT1后的语句
        goto NEXT1;
    else
        printf("1这里会被执行吗?\n"); 
        goto NEXT2;
        printf("2这里会被执行吗?"); 

    //跳转到此
    NEXT1:
        printf("a = %d  b = %d\n",a,b);
    NEXT2:
        printf("%d + %d = %d\n",a,b,a+b);
    //一个标签后面必须有一条语句
    FINISH:
        ;
    return 0;
}
```

### 9 函数

#### 9.1 函数的声明与定义

1. 格式:`返回类型  函数名  (形参列表)  {语句}`
   
   若一个函数不返回任何值或不含形参, 返回类型和参数列表可以用 `void`表示, 在传入变长数组时候用 `[*]`来表示, 其余类型必须为完整类型.

2. 存储说明符:只能有 `extern`与 `static`,若缺省默认则为 `extern`,`extern`表明函数有一个外部链接, `static`表明函数有一个内部链接.

```c
#include <stdio.h>
struct Mystruct;

//这里声明了函数MyFunc, 静态存储类， 返回类型为Mystruct
//形参s为不完整类型Mystruct(只声明不定义不会报错)
static struct Mystruct MyFunc(struct Mystruct s);

void Foo(void)
{
    puts("Hello World!");
}

struct Mystruct
{
    int a;
    float b;
};

//*Fun2(int)等价于 int* Fun2(int); (Fun3同理)
int Func(void),*Func2(int),(*Func3(void))[3];
int main()
{
    Foo();
    //定义MyFunc
    struct Mystruct MyFunc(struct Mystruct s)
    {
        return (struct Mystruct){s.a+=10,s.b-0.5f};
    }; 
    struct Mystruct s = MyFunc((struct Mystruct){10,2.5f});
    printf("%d  %.2f\n",s.a,s.b);
    return 0;
}
```

注意:

* 返回类型和形参类型都只能为完整类型或void类型

#### 9.2 *函数的实现和调用

`Foo();`后的 `()`就是函数调用操作符. 函数调用时,会将实际参数赋值给形参,在被赋值给形参之前, 必须完成计算.

* 圆括号的角色

| 圆括号内         | 圆括号角色 | 备注  |
| ------------ | ----- | --- |
| 类型名          | 投射操作符 |     |
| 表达式(括号前有函数名) | 函数调用  |     |
| 表达式          | 提升优先级 |     |

1. *函数调用顺序点
   
   对函数标志的计算与对 实参的计算谁先谁后是不确定的。
   
   ```c
   #include <stdio.h>
   static void Func1(void)
   {
       printf("F1\n");
   }
   int main()
   {
       void (*pFuncs[2])(int)= {&Func1,&Func2};
       int i= 0;
       //这里会发出警告,因为pFuncs[i]与i的计算是未确定顺序的,即对函数标志的计算与对实参的计算谁先谁后是不确定的。
       pFuncs[i++](i);
       return 0;
   }
   ```

2. 函数的栈空间
   
   每个函数都具有⾃⼰独⽴的上下⽂存储空间，此存储空间往往是栈式存储的，所以又被称为栈 （stack）空间。
   
   ```c
   #include <stdio.h>
   int main()
   {
       int a = 10; 
       /*
       (SP栈指针寄存器, 用于存放当前函数栈空间的地址)
       相当于SP -= 4; [SP] = 10;(汇编),这一步操作又叫压栈(Push)
       SP-=4表⽰SP指针先减去4个字节，
       然后[SP]=10表⽰将常量10存储到减去4之后的SP所指向的栈空间。
       */
       a += 20; 
       /*
       (reg表示某个寄存器)
       相当于reg = [SP]; reg += 20; [SP] = reg;
       函数返回前需要恢复栈空间，即把当前函数所使⽤的栈空间内容给⾃动回收
       这⾥相当于：reg = [SP]; SP += 4,这一步操作叫做出栈(Pop)
       */
       printf("%d\n",a);
       return 0;
   }
   ```

<img src="C:\Users\XIAOWEI\Desktop\Learn\C\note\1649997856044.png" alt="1649997856044" style="zoom: 67%;" />

3. 函数的参数传递与返回
   
   实参传递给形参时候,也需要栈空间操作.会将**被调函数**的形参所在的栈空间分配在**调用函数**的栈空间区域中(即让函数调用者负责将实参内容压栈,以此形式给被调用函数赋值).若被调函数要返回一个结构体对象, 以至于无法将内容放在一个寄存器中,那么该对象存放在被调函数的栈空间中,然后将该结构体对象的首地址放在寄存器中返回出去.   函数调⽤者需要通过SP指针将被调函数所返回的结构体内容拷贝到⾃⼰的栈空间中去。

```c
#include <stdio.h>
struct MyStruct
{
    int i;
    float f;
};

static struct MyStruct Foo(int a, float b)
{
    struct MyStruct s = {a,b};
    s.i +=10;
    s.f -=0.5f;
    return s;
}

int main()
{
    struct MyStruct s = Foo(10,2.3f);
    printf("%d  %.2f\n",s.i,s.f);
    return 0;
}
```

<img src="C:\Users\XIAO\Desktop\Stu\C\note\1649997956241.png" alt="1649997956241" style="zoom:80%;" />

4. 通过形参修改实参的值
   
   利用指针, 通过函数来修改函数调⽤者对象的值.将函数调用者的某个对象的地址作为实参传递给被调用函数形参,被调用函数就可以修改该对象的值.
   
   ```c
   #include <stdio.h>
   static void MySwapFunc(int *p,int *q)
   {
       int temp = *p;
       *p = *q;
       *q = temp;
   }
   int main()
   {
       int a = 12,b= 15;
       MySwapFunc(&a,&b);
       printf("a = %d, b = %d\n",a,b);
       //输出a = 15, b = 12
       return 0;
   }
   ```

#### 9.3 *数组类型作为函数形参

如果一个函数的形参是一个数组类型的对象, 那么它会被调整为指向该数组元素类型的指针, 同时如果类型还有限定符(比如 `const`或 `volatile`), 那么可以在表示数组对象对象的[]里添加. 如果在[]中含有 `static`关键字,那么实参必须确保至少访问该形参所指定元素个数的元素数量.此外, 还可以用 `[*]`来表示变长数组类型.

```c
#include <stdio.h>
static void func1(int a[*]);
static void func1(int a[])
{
    //这里对func1进行了定义，但int[*]是一个不完整类型, 就不能使用[*]
    //尽管如此,int[]会被自动转换为int*,当形参为数组类型时,会被自动转换为指向数组的指针,所以形参就是int*类型
    if (a != NULL)
        printf("a[0] = %d\n",a[0]);
    //这里的sizeof(a)实际上是sizeof(int*)
    printf("size of a = %zu\n",sizeof(a));
}

static void func2(int a[])
{   
    //当形参为一个数组的时候, 无论数组的长度有多少都不会有有用, 这是因为都会被转换为指向该数组的指针
    if (a ==NULL)
        puts("null");
        printf("size of a = %zu\n",sizeof(a));
}

//括号内的static表示,实参所指的数组至少有5个int元素对象
//const 用来表示对形参a做了常量限定, a不能指向其他对象地址(a也无法被修改)
static void func3(int a[static const 5])
{
    int sum = 0;
    for (int i = 0;i <5;i++)
        sum +=a[i];
        a[0] = 100;
        printf("sum = %d   a = %d\n",sum,*a);

}

static void func4(int a[static const 2][3])
{
    printf("size of a[0]: %zu\n",sizeof(*a));
    a[1][2] = 20;
    printf("a [1][2] = %d\n",a[1][2]);
}
int main()
{
    int a[5] = {11,20,30,0,0};
    func1(a);
    func2(a);
    func3(a);
    int b[2][3] = {};
    func4(a);
    return 0;
}
```

#### 9.4 带有不定参数类型及个数的函数声明与调用

```c
//正确使用
void func(int a,...);
//错误一:...前至少有一个形参
void func(...);
//错误二:...后没有形参
void func(int a,...int b);
```

1. 由于不定参数列表中每个参数的类型是不确定的, 因此C语言编译器会将任何等级小于int的类型转换为int; float会被晋升为double.

2. * 在获取带有不定参数时，需要借助`<stdarg.h>`标准头文件,这个标准文件中定义了4个宏,用于遍历传入的实参列表, 其中`va_list`:用来保存`va_start`、`va_arg`、`va_end`、`va_copy`这4个宏函数在操作过程中所需要的状态信息.
   * `va_start`:只能被调用一次,`va_start`的第二个参数需传入`...`之前的形参对象, 以定位不定参数列表的起始位置.
* `va_arg`:该宏第一个参数为ap,每执行一次 `va_arg`时, ap会被自动修改为下一个实参的值,同时ap也会被指定到下一个实参的位置,然后返回.
  
  * `va_end`:当获取完不定参数的列表后, 调用`va_end`来无效化ap, 这样ap就不可以再使用了
  * `va_copy`: 该宏初始化其第⼀个参数dest作为其第⼆个参数src的⼀个拷贝， 两者都是va_list类型的对象。  如果src对象已经通过va_start进⾏了初始化， 并且通过⼏次va_arg的迭代，那么这就好⽐先对dest调⽤了va_start宏，然后 迭代地调⽤va_arg宏，直到dest的状态与src的状态相同。
  
  ```c
  #include <stdio.h>
  #include <stdarg.h>
  #include <stdint.h>
  
  static void test1(int n,...)
  {
      //先声明一个va_list类型的对象ap
      va_list ap;
  
      /*
      1.开始访问...所对应的实参前,必须先调用va_start,对ap进行初始化这样才能让va_arg, va_end所使用
      2.对ap初始化,并指明形参n是紧跟在...之前的形参
      */
      va_start(ap,n);
  
      //开始获取第一个实参,类型为int
      int a = va_arg(ap,int);
  
      //迭代获取第二个实参,类型为unsigned
      unsigned b = va_arg(ap,unsigned);
  
      //迭代获取第三个实参,类型为double
      double c = va_arg(ap,double);
  
      //结束迭代,对ap作无效化处理
      va_end(ap);
  
      printf("test 1 & result = %.4f\n",n+a+b+c);
  }
  
  static double func(int n,va_list ap)
  {
      //在个函数中无需对ap作va_start的初始化和va_end的无效化
      int a = va_arg(ap,int);
      unsigned b= va_arg(ap,unsigned);
      double c = va_arg(ap,double);
      return n+a+b+c;
  }
  
  static void test2(int n, ...)
  {
      va_list ap;
      va_start(ap,n);
      //将初始化完成的ap作为实参传递给func
      double result = func(n,ap);
      va_end(ap);
      printf("test 2 & result = %f\n",result);
  }
  
  struct my_struct {int a,b;};
  union my_union{char c;short s;};
  
  //自定义类型也可以作为不定参数类型
  static void test3(int a,...)
  {
      va_list ap;
      va_start(ap,a);
      struct my_struct s =va_arg(ap,struct my_struct);
      //这里un只有两个字节大小,但是默认会被晋升
      union my_union un=va_arg(ap,union my_union);
      printf("size of un:%zu\n",sizeof(un));
      va_end(ap);
  
      int result = a +s.a+s.b-un.s;
      printf("test 3 & reslut = %d\n",result);
  }
  
  int main()
  {
      int8_t a = 10;
      uint16_t b = 20;
      float c = 2.3f;
  
      test1(30,a,b,c);
      test2(30,a,b,c);
      test3(30,(struct my_struct){1,2},(union my_union){.s = 11});
      return 0;
  }
  ```

#### 9.5 递归调用

```c
#include <stdio.h>
static void func(int n)
{
    if (n == 0)
    {
        puts("LOOP OVER!");
        return;
    }
    printf("LOOP LEVEL:%d\n",n);
    func(n-1);
}

int main()
{
    func(2);
    return 0;
}
```

优势与不足: 看起来简洁, 但是循环效率更高

```c
/*
斐波那契数列指的是这么⼀个数列：0，1，1，2，3，5，8，13，21……其中0属于第0项，1属于第1项。从第2项开始，当前项的数是其之前两项数的和，所以可以⽤这个数学⽅程来表达：Fn=F（n-1）+F（n-2），n>1且n属于⾃然数。
*/

//递归法求斐波那契数列指定的值
#include <stdio.h>
static int func(int n)
{
    if(n == 0)return 0;
    if(n == 1)return 1;
    return func(n-1)+func(n-2);
}
int main()
{
   int n = 5;
   printf("%d\n",func(n));
    return 0;
}
```

&递归流程图

<img src="C:\Users\XIAO\Desktop\Stu\C\note\1650090364616.png" alt="1650090364616" style="zoom: 67%;" />

```c
//循环法
#include <stdio.h>
int main()
{
    int former = 0,corrent = 1,n = 3,value;
    for(int i;i <n;i++)
    {
       value = corrent;
       corrent = former +corrent;
       former = value;
    };
    printf("%d\n",corrent);
    return 0;
}
```

#### 9.6 *内联函数

如果⼀个函数⽤`inline`函数说明符进⾏声明，那么该函数是⼀个内联函数。内联函数是对C语⾔编译器的暗⽰，建议编译器对该函数的调⽤尽可能地快。
注意:

* 对于具有外部连接函数的限制
  * 若一个函数用`inline`函数说明符声明, 那么它也应该定义在同一翻译单元中.
  * 若对一个函数在所有文件作用域的声明,在某一翻译单元中, 有`inline`但是没有`extern`,则该翻译单元中的定义是一个内联定义.
  * 内联定义不提供对该函数的外部 定义，并且也不禁⽤它在另⼀个翻译单元中的外部定义。内联定义提供了对⼀个外部定义的替代品，编译器可以⽤来实现在同⼀翻译单元中对该函 数的任⼀调⽤（选择内联定义的调⽤或外部定义的调⽤）。对函数的调⽤ 使⽤的是内联定义还是外部定义则是未指定的。
  * 具有外部连接的⼀个函数的内联定义，不应该包含具有静态或线程存 储周期的⼀个可修改对象，并且也不应该包含对⼀个具有内部连接标识符的引⽤。

#### 9.7 函数返回类型和无返回函数

* 函数的返回类型⼏乎可以是任意类型，包括整型、浮点 型等基本类型，枚举、结构体、联合体等⽤户⾃定义类型，也可以是指向上述这些类型的指针，但唯独不允许数组类型。
* 除了返回类型为void的情况外，⼀个函数中的任⼀分⽀代码最终必须要触碰⼀条return语句进⾏函数返回。 void返回类型会自动在末尾添加`return;`

#### 9.8 指向函数的指针

通用表达式:`返回类型 (* cv限定符可选)(形参列表)`,  cv限定符即为const、volatile限定符.

```c
#include <stdio.h>
#include <stdarg.h>
struct MyStruct;

static struct MyStruct (*p)(struct MyStruct s,int a[*]) = NULL;

static void Test(void);

static int Foo(int n,...)
{
    va_list ap;
    va_start(ap,n);
    int sum= 0;
    for (int i = 0;i<n;i++)
        sum += va_arg(ap,int);
    va_end(ap);
    return sum;
}

int main()
{
    //声明了指向函数Test的指针对象pf
    //由于*优先级较高,所以需要()
    void(*pf)(void) =Test;
    (*pf)();
    int (*pFunc)(int,...) = &Foo;

    //利用指针, 间接调用函数
    int result = pFunc(3,10,20,30);
    printf("*pFunc : result = %d\n",result);

    //指向函数指针的指针
    int(**pp)(int,...) = &pFunc;
    result = (*pp)(5,1,2,3,4,5);
    printf("**pp : result = %d\n",result);

    //指向NULL
    *pp = NULL;
    if (pFunc ==NULL)puts("NULL");
    return 0;
}


struct MyStruct
{
    int a;
    float f;
};

static struct MyStruct Func(struct MyStruct s,int a[])
{
    printf("sum = %.4f\n",s.a + s.f+a[0]);
    return s;
}
static void Test(void)
{
    p = Func;
    p((struct MyStruct){.a = 10,.f = 0.5f},(int[]){1,2,3});
}
```

注意:

* 声明指向函数的指针对象时, 形参列表与返回类型的要求与一般函数声明要求一样, 返回类型可以是完整型, 也可以是不完整类型.
* ⼀个函数标志本⾝即可表⽰为⼀个指向该函数 类型的指针，⽽如果在它前⾯加地址操作符&，同样也表⽰指向该函数的 指针，两者在类型上是完全等同的。
* 指向函数的指针对象也能作为⼀个函数的参数，同时⼀个函数的返回类型也可以为指向函数的指针类型。

#### 9.9主函数main

```c
#include <stdio.h>

int main(int argc,char*argv[])
{
    //argc⼀般存放执⾏当前程序时输⼊的命令字符串个数；argv则存放了指向各个输⼊字符串的指针。
    //argc应该是一个非负数,argv应该是一个空指针
    puts("OK!");

    //若缺省return,则默认为return 0;
    return 0;
}
```

注意:

* 程序默认的入口函数就是main函数，因此main函数必须要有外部连接，它不能是static的。
* main函数也不能带有`inline`、`_Noreturn`等 函数说明符

#### 9.10 函数与函数调用作为sizeof操作符

1. `sizeof()`不应该用于:
* 具有函数类型
* 一个不完整类型的表达式
* 访问一个位域成员
2. `_Alignof`操作符不应该用于一个函数类型或不完整类型.
3. 如果`sizeof()`的操作数是⼀个函数调⽤表达式，那么它的结果相当于`sizeof（函数返回类型）`，同时，作为`sizeof`操作数的函数调⽤将不会发⽣。

```c
#include <stdio.h>

static int func0()
{
    puts("func0");
    return 0;
}

static void func1()
{
    puts("func1");
}

int main(void)
{
    printf("size of func0() ; %zu\n",sizeof(func0()));
    //func1返回类型为void, 属于不完整类型, 理论上是未定义的, 但是在gcc上结果为1
    printf("size of func1() ; %zu\n",sizeof(func1()));
    printf("size of &func1 ; %zu\n",sizeof(&func1));
    return 0;
}
```

### 10 预处理器

预处理阶段就是把将一些字符符号直接换到源代码中，C语言中有三大类预处理指示符：条件段、控制行、空。

* 在所有的预处理指示符中，只有_Pragma不需要以#开头。
* 预处理指示符后不用添加分号
* 当需要被替换的内容比较长的时候，可以用换行符`\`来换行。

#### 10.1 宏定义（控制行类）

以一个#define定义的一个符号就叫作宏（macro），#与define之间不要添加空白（其他的预处理命令也是这样），避免无法被识别。

定义宏的两种方式：

* #define 标识符 替换列表 换行符        //类似对象，替换列表可以省略
* #define 标识符（参数列表） 替换列表 换行符        //类似函数，替换列表可以省略，实参可以不传

1.宏的基本使用

```c
#define MaxSize 100    //可以将源代码中的MaxSize都替换为100
#define Fun int foo(void){return 0;}       //将fun替换为代码int foo(void){return 0;}
```

2.操作符#

如果在替换列表中使用`#形参名`,那么这部分就会被传入的参数所替换掉。

* 如果替换后是无效的，那么结果是未定义的

* 传入的参数可以为空，但是传入参数的个数一定要与形参个数相同

```c
#include<stdio.h>

#define MY_MACRO(x,y) #x"&&"#y

int main(){
    printf("%s\n",MY_MACRO(x,4));//输出结果：x&&4
    printf("%s\n",MY_MACRO(,4));//合法
    printf("%s\n",MY_MACRO(x,));//合法
    printf("%s\n",MY_MACRO());//非法 报错
    return 0;
}
```

* 可以作为预处理符号的元素：头文件名、标识符、预处理数字、字符（串）常量、标点符号
  
  ```c
  #define MY_MACRO(stdio,printf) #stdio"&&"#printf    //这段代码也是可以的
  ```

3.操作符##

将形参和替换列表中的内容完全融合起来。  与操作符#不同的是，##还可以把替换列表中的两个预处理符号拼接起来（操作符#只可以拼接宏函数的形参）。

```c
#include<stdio.h>

#define MY_MACRO_1(x) x ## 5
#define MY_MACRO_2(x) 0x ## x
#define MY_MACRO_3(x,y)    x##0 + 0x##y 
#define MY_MACRO_4(x,y) x##y

int main(){
    printf("%d\n",MY_MACRO_1(10));    //输出：4567
    printf("%d\n",MY_MACRO_2(64));    //输出：被替换为0x64，由于格式化符合是%d，所以输出100
    printf("%d\n",MY_MACRO_3(10,32));    //输出：150
    printf("%d\n",MY_MACRO_4(10,24));    //输出：1024
    return 0;
}
```

4.宏替换

* 同一文件作用域内，不能出现名称相同的宏标识符，除非这两个的替换列表完全相同。

* 一个宏定义可以引用另外一个已经定义好的宏，但是无法实现递归式调用。
  
  ```c
  #include<stdio.h>
  
  #define CONCAT(x,y) x##y##ELLO
  #define LITERAL(x) #x
  #define MY_MACRO2(x) LITERAL(x)
  #define def 100
  #define H abcd
  
  int main(){
      printf("%s\n",MY_MACRO2(CONCAT(if,def H)));
      /*
      * 第一步：对MY_MACRO2进行宏替换，结果为LITERAL（x）；
      * 第二步：对LITERAL（x）进行宏替换，得到#x
      * 第三步：对实参CONCAT(if, def H)进⾏宏替换，得到：x ## y ## ELLO ；
      * 由于这⾥CONCAT宏的替换列表含有##操作符，因此不会对实参宏def和H进⾏扩展，
      * 第四步将实参if和def H替换形参之后，结果为ifdef HELLO；
      */
      return 0;
  }
  ```

* 预处理器会不换迭代解析替换列表中定义的宏，直到全部解析完成。**宏函数的替换顺序：优先替换出现的#和##操作符，然后对替换列表中出现的宏进行展开替换，接着检查实参中的宏，如果实参中有宏，就替换实参中的宏，最后再将替换列表中出现的形参替换为宏扩展后的实参对应点预处理符号。**

* 如果替换后出现了#defin或是#ifdef这样的结果，这样的结果不会被当做预处理指示符进行处理

**疑问：**

```c
#define CONCAT(x,y) LITERAL(x)##LITERAL(y)	//为什么会报错？
#define LITERAL(x) #x
```

预操作符##优先被处理：会将`LITERAL(x)##LITERAL(y)`替换为`LITERAL(x)LITERAL(y)`,`LITERAL(x)LITERAL(y)`并不是一个合法的预处理符号。

5.不定参数个数
* 使用示例
```c
#include<stdio.h>
#define VAR_MACRO(...) printf(__VA_ARGS__)
int main(){
    VAR_MACRO("Good Luck, %s\n","Morty!");
    //将会被替换为printf("Good Luck, %s\n","Morty!");
    return 0;
}
```
* 注意事项
  * 替换列表中的__VA_ARGS__是固定的，不可以修改。
  * 当宏定义为`#define VAR_MACRO(str,...) printf(str,__VA_ARGS__)`时候，由于`...`部分可以不传入参数，这个时候如果只传入一个参数，替换后就会变为`printf(str,);`,就会报错，无法编译通过，同时，这也说明：在于处理的时候是不做语法分析的。


* 示例2


```c
#include<stdio.h>

#define VAR_MACRO(str,...) printf(str,__VA_ARGS__)
#define VAR_MACRO_CAL(a,...) (a __VA_ARGS__ 10)
int main(){
    VAR_MACRO("Good Luck %d\n",10);
    VAR_MACRO("output = %d\n",VAR_MACRO_CAL(10,+10*));
    /*
    *分别被替换为：
    *printf("Good Luck %d\n",10);
    *printf("output = %d\n",(10 +10* 10));
    */
    return 0;
}
```  
#### 10.2 C语言中预定义的宏(由编译工具定义好的宏)
* 预定义的宏分为四大类
  * C标准中强制要求预定义的宏
  * 环境宏（可选实现的预宏定义）
  * 条件特征宏（可选实现的预定义宏）
  * 依据不同平台自己定义的宏
* 部分预定义宏使用示例


```c
#include<stdio.h>
int main(){
    //强制要求
    PRINT_MACRO(__DATE__);
    PRINT_MACRO(__FILE__);
    printf("%d\n",__LINE__);    //当前程序有多少行代码
    printf("%d\n",__linux__);   
    printf("%d\n",__STDC__);    //是否是C标准
    PRINT_MACRO(__TIME__);
    printf("%ld\n",__STDC_VERSION__);//C标准版本
    //环境宏
    printf("%d\n",__STDC_UTF_32__);
    //
    return 0;
}
```


#### 10.3 条件预编译
当条件预编译的条件为真的时候，这段预编译代码才会参与编译。

1.#defined
* defined的两种形式
  * defined 标识符
  * defined (标识符)
* **defined的使用：** 
  * defind 表达式只可以与#if联合起来使用，不可以在其他的场合使用。
  * defined后应该是一个宏名，如果被定义defined的值就为1，否者为0。
  * defined可以参加算术逻辑运算：例如！defined 后的标识符如果被定义过，那么表达式的值为0。

2.#if、#elif、#else、#ifdef、#idndef
* 注意事项
  * #if和#elif后应该是一个有效的，适用于预处理的常量表达式。
  * 当该编译组判定都结束后，最后必须以#endif来结尾，#endif后只能是换行符，不能是其他的符号。
  * 如果#if或#elif后是一个未被定义的标识符，那么这个条件判断结果就为假，其下面的条件不会参加编译。
  * 枚举类型不属于预定义标识符。
  * #if和#elif后不可以跟函数，例如下列代码。
     ```c
        #if aa == sizeof(int)
        #define SIZE 4
        #endif
     ```
     因为sizeof()这样的函数只能用于c代码的编译期间。
  * #ifdef可以看做是#if defined() 的简写，但是#ifdef后只能是宏名。
  * #ifndef 如果没有定义某个宏，判断结果为真。

#### 10.4 源文件包含预处理指示符
* #include的两种形式
  * #include<文件名>：在操作系统放头文件的地方寻找或是在用户指定的系统环境中寻找头文件。
  * #include"文件名"：在指定文件夹中寻找，找不到就用<>的方式来找，如果还是找不到，那么就报错。
* 使用#ifndef和#define可以防止该一个头文件被某一个源文件多次包含。例如,在stdio.h中：
  *

 ```c
    #ifndef _STDIO_H
    #define _STDIO_H    1
    /*
    *一大串代码...
    */
    #endif
    ```
* #include后跟宏名
  *这样可以用一个宏对象来指定要包含的文件名。例如：
  ```c
    #define DEMO_MACRO
    #ifdef DEMO_MACRO
        #define HEADER_FILE "header_files_x.h"
    #else
        #define HEADER_FILE "header_files_y.h"
    #endif
    #include HEADER_FILE
    //上述代码：如果定义了宏DEMO_MACRO，引入的头文件是header_files_x.h，否者是头文件header_files_y.h
  ```

#### 10.5 #error和#warning预处理指示符
其作用是在预处理过程中报出指定的错误或者警告诊断信息。格式：
```c
#error 错误信息
#warning 警告信息
```
例如：
```c
#define SAFE_MACRO 10

#ifndef SAFE_MACRO
//没有定义SAFE_MACRO时会报错
#error safe macro not defined!
#endif

#error
//这里会直接报错
```

一些编译器还支持#warning，用法和#error一样，但是#warning并不会像#error一样打断程序的编译，只会警告。

#### 10.6 #line预处理指示符
* 作用
  * line后的数字是下一行的行号，
    ```c
    #line 数字
    ```
  * 来修改当前的源文件名
    ```c
    #line 数字 "源文件名"
    ```

* 示例

```c
#include<stdio.h>

int main(){
    #line 10
    printf("line:%d,file name:%s\n",__LINE__,__FILE__);
    /*line:10,file name:/home/me/Desktop/Learn/C/code/others_test.c
    *实际行号为5，但被#line定义为了第10行
    */
    printf("line:%d\n",__LINE__);
    /*
    *实际行号为9，但由于上一个#line规定的行号，输出line：14
    */
    #line 100 "/home/me/Desktop/Learn/C/code/rename.c"
    printf("line:%d,file name:%s\n",__LINE__,__FILE__);
    /*line:100,file name:/home/me/Desktop/Learn/C/code/rename.c
    * 可以发现，行号和文件名已经被修改。这里需要注意，在修改文件名的时候，行号是不可以省略的。
    */
    return 0;
}
```

#### 10.7 #undef 预处理指示符

取消已经定义好的宏，如果是没被定义过的也没关系，预处理器也不会报错。
```c
#undef 宏的标识符
```

#### 10.8 #pragma和_Pragma
#pragma和_Pragma都是指示符，用于指示当前翻译单元使用某种编译特性来进行编译（指定那些函数用某个选项进行优化、从哪里开始使用标准浮点约定等），但是_Pragma的用法更为灵活，可以用于宏定义的替换列表中。

`#pragma 预处理符号 换行符`

#pragma用法：

`pragma STDC 标准支持的编译选项 开关值 换行符`
* 开关值：ON、OFF、DEFAULT

_Pragma用法：

`_Pragma (字符串字面量)` 
* 她后面还可以直接跟函数、结构体类型等元素的定义




